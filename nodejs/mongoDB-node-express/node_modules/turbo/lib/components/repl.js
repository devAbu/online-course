"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@turbo/core");
const react_1 = __importDefault(require("react"));
const renderer_1 = require("../renderer");
const eval_1 = require("./eval");
const helpers_1 = require("./helpers");
const breakpoints_1 = require("./breakpoints");
const stack_1 = require("./stack");
const PROMPT = "> ";
function js(str) {
    return str;
}
const COMMANDS = [
    { type: "help", alts: ["h", "?"] },
    { type: "quit", alts: ["q"] },
    { type: "start", alts: ["run"] },
    { type: "stop", alts: [] },
    { type: "restart", alts: [] },
    { type: "pause", alts: ["p"] },
    { type: "resume", alts: ["r", "c"] },
    { type: "stepInto", alts: ["i", "stepi"] },
    { type: "stepOver", alts: ["n", "step", "stepOver"] },
    { type: "stepOut", alts: ["finish", "f"] },
    { type: "stack", alts: ["backtrace", "bt"] },
    { type: "break", alts: ["b"] },
    { type: "unbreak", alts: ["ub"] },
    { type: "breaks", alts: ["bs"] },
    { type: "eval", alts: ["e"] },
    { type: "up", alts: [] },
    { type: "down", alts: [] },
];
const SIMPLE_RUNTIME_COMMANDS = {
    start: "start",
    stop: "stop",
    restart: "restart",
    pause: "pause",
    resume: "resume",
    stepInto: "stepInto",
    stepOver: "stepOver",
    stepOut: "stepOut",
    up: "focus-up",
    down: "focus-down",
};
function isSimpleRuntimeCommand(type) {
    return Object.keys(SIMPLE_RUNTIME_COMMANDS).includes(type);
}
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function getCommandArgs(command, input) {
    return input.replace(RegExp(`^${escapeRegExp(command)}`), "").trim();
}
function findCommandMatch(input, options) {
    const e = escapeRegExp;
    return options.find(o => RegExp(`^${e(o)}\\s+`).test(input) || o === input);
}
function parse(input) {
    for (const command of COMMANDS) {
        const options = [command.type, ...(command.alts || [])];
        const match = findCommandMatch(input, options);
        if (match) {
            const args = getCommandArgs(match, input);
            return { type: command.type, args: args };
        }
    }
    return { type: "eval", args: input };
}
function Help() {
    return (react_1.default.createElement(renderer_1.Box, { direction: "column" },
        react_1.default.createElement(renderer_1.Box, null, "turbo help:"),
        react_1.default.createElement(renderer_1.Box, null),
        COMMANDS.map((c, i) => (react_1.default.createElement(renderer_1.Box, { key: i },
            c.type,
            c.alts ? ` - ${c.alts.join(",")}` : "")))));
}
function isInteger(str) {
    const n = Math.floor(Number(str));
    return n !== Infinity && String(n) === str && n >= 0;
}
async function handle(turbo, input, client) {
    if (/^\s*$/.test(input)) {
        return null;
    }
    const state = client.state;
    if (!state) {
        return null;
    }
    const target = state.target;
    const trimmed = input.trim();
    const cmd = parse(trimmed);
    if (!cmd) {
        return react_1.default.createElement(renderer_1.Box, { color: "red" },
            "unable to parse command $",
            input);
    }
    else if (cmd.type == "help") {
        return react_1.default.createElement(Help, null);
    }
    else if (cmd.type == "quit") {
        client.quit();
    }
    else if (isSimpleRuntimeCommand(cmd.type)) {
        client.dispatch({ type: SIMPLE_RUNTIME_COMMANDS[cmd.type] });
    }
    else if (cmd.type === "stack") {
        if (state.target.paused) {
            return react_1.default.createElement(stack_1.Stack, null);
        }
        else {
            return react_1.default.createElement(renderer_1.Box, { color: "red" }, "not paused");
        }
    }
    else if (cmd.type === "break" || cmd.type === "unbreak") {
        const scriptId = state.target.paused
            ? state.target.callFrames[state.target.focusedCallFrame].location
                .scriptId
            : undefined;
        const script = helpers_1.getScript(state, scriptId);
        const parts = cmd.args.split(" ");
        const linePart = parts[0];
        const columnPart = parts[1];
        const hasLine = isInteger(linePart);
        const hasCol = isInteger(columnPart);
        if (!hasLine || (!hasCol && columnPart)) {
            return react_1.default.createElement(renderer_1.Box, { color: "red" }, "invalid args to break");
        }
        if (!script) {
            return react_1.default.createElement(renderer_1.Box, { color: "red" }, "unable to get script");
        }
        const line = Number(linePart) - 1;
        const column = hasCol ? Number(columnPart) - 1 : undefined;
        if (cmd.type === "break") {
            client.dispatch({
                type: "set-breakpoint",
                breakpoint: {
                    id: core_1.uuid(),
                    line,
                    column,
                    url: script.url,
                    rawUrl: script.rawUrl,
                    raw: undefined,
                },
            });
        }
        else {
            const matches = state.target.breakpoints.filter(b => b.rawUrl === script.rawUrl &&
                b.line === line &&
                (!column || b.column === column));
            for (const match of matches) {
                client.dispatch({
                    type: "remove-b-request",
                    id: match.id,
                });
            }
        }
    }
    else if (cmd.type === "breaks") {
        return react_1.default.createElement(breakpoints_1.Breakpoints, { breakpoints: state.target.breakpoints });
    }
    else if (!target.paused) {
        return react_1.default.createElement("span", null, "not paused");
    }
    else {
        const callFrame = target.callFrames[target.focusedCallFrame];
        return client
            .eval(cmd.args, callFrame.id)
            .then(result => react_1.default.createElement(eval_1.Eval, { result: result }))
            .catch(error => {
            return react_1.default.createElement("span", null,
                "`eval error: $",
                error,
                "`");
        });
    }
    return null;
}
function Repl() {
    const client = helpers_1.useClient();
    const turbo = helpers_1.useTurbo();
    const [lines, setLines] = react_1.default.useState([]);
    async function onSubmit(value) {
        const newLines = [
            ...lines,
            react_1.default.createElement("span", { key: lines.length }, PROMPT + js(value)),
        ];
        setLines(newLines);
        const output = await handle(turbo, value, client);
        if (output) {
            setLines([
                ...newLines,
                react_1.default.createElement("span", { key: newLines.length }, output),
            ]);
        }
    }
    return (react_1.default.createElement(renderer_1.Box, { direction: "column" },
        react_1.default.createElement(renderer_1.ScrollableBox, { direction: "column", grow: 1, snapToBottom: true },
            lines,
            react_1.default.createElement(renderer_1.Input, { prompt: PROMPT, onSubmit: onSubmit }))));
}
exports.Repl = Repl;
//# sourceMappingURL=repl.js.map