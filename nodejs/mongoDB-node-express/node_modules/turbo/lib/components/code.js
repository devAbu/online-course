"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@turbo/core");
const react_1 = __importDefault(require("react"));
const renderer_1 = require("../renderer");
const helpers_1 = require("./helpers");
function Numbers(props) {
    const width = String(props.height).length;
    const elements = [];
    for (let i = 0; i < props.height; i++) {
        elements.push(String(i + 1).padStart(width, " "));
    }
    return react_1.default.createElement(renderer_1.Box, { direction: "column" }, elements);
}
function Gutter(props) {
    const state = helpers_1.useClientState();
    const callFrame = helpers_1.useFocusedCallFrame();
    if (!state)
        return react_1.default.createElement(renderer_1.Box, null);
    const breakpoints = state.target.breakpoints;
    const breakpointsByLine = breakpoints.reduce((map, breakpoint) => {
        map[breakpoint.line] = breakpoint;
        return map;
    }, {});
    const elements = [];
    for (let i = 0; i < props.height; i++) {
        if (callFrame && i === callFrame.location.line) {
            elements.push(react_1.default.createElement(renderer_1.Box, { key: i, height: 1, width: 2, color: "red" }, " >"));
        }
        else if (breakpointsByLine[i]) {
            elements.push(react_1.default.createElement(renderer_1.Box, { key: i, height: 1, width: 2, color: "red" }, " O"));
        }
        else {
            elements.push(react_1.default.createElement(renderer_1.Box, { key: i, height: 1, width: 2 }, "  "));
        }
    }
    return react_1.default.createElement(renderer_1.Box, { direction: "column" }, elements);
}
function LogoText(props) {
    return (react_1.default.createElement(renderer_1.Box, { direction: "column" },
        react_1.default.createElement(renderer_1.Box, { direction: "column" }, core_1.LOGO.split("\n")),
        props.children));
}
function Code() {
    const state = helpers_1.useClientState();
    const callFrame = helpers_1.useFocusedCallFrame();
    const script = helpers_1.useScriptSource(callFrame ? callFrame.location.scriptId : undefined);
    const lines = react_1.default.useMemo(() => helpers_1.highlightJs(script).split("\n"), [
        script,
    ]);
    if (!state) {
        return (react_1.default.createElement(LogoText, null,
            react_1.default.createElement(renderer_1.Box, { wrap: true }, "The component has not synced with the daemon.")));
    }
    else if (state.target.paused && callFrame) {
        const height = lines.length;
        const loc = callFrame.location;
        return (react_1.default.createElement(renderer_1.ScrollableBox, { grow: 1, direction: "row", desiredFocus: loc.line },
            react_1.default.createElement(Numbers, { height: height }),
            react_1.default.createElement(Gutter, { height: height }),
            react_1.default.createElement(renderer_1.Box, { direction: "column", grow: 1 }, lines)));
    }
    else if (state.target.connected) {
        return (react_1.default.createElement(LogoText, null,
            react_1.default.createElement(renderer_1.Box, { wrap: true }, "The target is not paused."),
            react_1.default.createElement(renderer_1.Box, { wrap: true, marginTop: 1, color: "gray" }, "Hint: You can pause the target with the \"pause\" or \"p\" commands in the repl.")));
    }
    else {
        return (react_1.default.createElement(LogoText, null,
            react_1.default.createElement(renderer_1.Box, { wrap: true }, "The target is not running."),
            react_1.default.createElement(renderer_1.Box, { wrap: true, marginTop: 1, color: "gray" }, "Hint: You can restart the target with the \"start\" or \"restart\" commands in the repl.")));
    }
}
exports.Code = Code;
//# sourceMappingURL=code.js.map