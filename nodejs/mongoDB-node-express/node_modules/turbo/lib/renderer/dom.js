"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const yoga = __importStar(require("yoga-layout-prebuilt"));
const style_1 = require("./style");
const string_width_1 = __importDefault(require("string-width"));
const ansi_1 = require("./ansi");
function findClosestParent(node, matcher) {
    if (node.parent) {
        if (matcher(node.parent)) {
            return node.parent;
        }
        else {
            return findClosestParent(node.parent, matcher);
        }
    }
    else {
        return undefined;
    }
}
exports.findClosestParent = findClosestParent;
function resolveProperty(node, getter) {
    if (node.parent) {
        const parentValue = getter(node.parent);
        if (typeof parentValue !== "undefined") {
            return parentValue;
        }
        else {
            return resolveProperty(node.parent, getter);
        }
    }
    else {
        return undefined;
    }
}
exports.resolveProperty = resolveProperty;
function forAllComplexChildren(node, cb, x = 0, y = 0) {
    let drawOffsetTop = 0, drawOffsetLeft = 0;
    const drawOffsetTopParent = findClosestParent(node, n => n.drawOffsetTop !== undefined);
    if (drawOffsetTopParent) {
        drawOffsetTop = drawOffsetTopParent.drawOffsetTop || 0;
    }
    const drawOffsetLeftParent = findClosestParent(node, n => n.drawOffsetLeft !== undefined);
    if (drawOffsetLeftParent) {
        drawOffsetLeft = drawOffsetLeftParent.drawOffsetLeft || 0;
    }
    const nodeX = x + node.yoga.getComputedLeft();
    const nodeY = y + node.yoga.getComputedTop();
    cb(node, nodeX + drawOffsetLeft, nodeY + drawOffsetTop);
    for (const child of node.children) {
        if (child.type === "complex") {
            forAllComplexChildren(child, cb, nodeX, nodeY);
        }
    }
}
exports.forAllComplexChildren = forAllComplexChildren;
function forAllTextChildren(node, cb) {
    for (const child of node.children) {
        if (child.type === "text") {
            cb(child);
        }
        else {
            forAllTextChildren(child, cb);
        }
    }
}
exports.forAllTextChildren = forAllTextChildren;
function cloneNode(node) {
    if (node.type === "text") {
        const newNode = createTextNode(node.value);
        updateTextNodeLayout(newNode);
        return newNode;
    }
    else {
        const newNode = createNode(node.name);
        applyAttributes(newNode, node.attributes);
        for (const child of node.children) {
            const newChild = cloneNode(child);
            appendChildNode(newNode, newChild);
        }
        return newNode;
    }
}
exports.cloneNode = cloneNode;
function createNode(name) {
    const node = {
        type: "complex",
        name: name.toLowerCase(),
        yoga: yoga.Node.create(),
        children: [],
        parent: null,
        attributes: {},
        wrap: false,
        drawOverflow: true,
    };
    return node;
}
exports.createNode = createNode;
function createContainer(target) {
    return {
        drawing: false,
        node: createNode("#root"),
        target,
        forceRedraw: false,
    };
}
exports.createContainer = createContainer;
function calculateTextHeight(node, width) {
    const root = createNode("#root");
    const style = {
        width,
    };
    applyAttributes(root, { style });
    const clone = cloneNode(node);
    appendChildNode(root, clone);
    forAllTextChildren(root, updateTextNodeLayout);
    root.yoga.calculateLayout(width, 1, yoga.DIRECTION_LTR);
    const height = clone.yoga.getComputedHeight();
    root.yoga.freeRecursive();
    return height;
}
exports.calculateTextHeight = calculateTextHeight;
function updateTextNodeLayout(node) {
    if (!node.parent)
        return;
    const childrenToRemove = [];
    for (let i = 0; i < node.yoga.getChildCount(); i++) {
        childrenToRemove.push(node.yoga.getChild(i));
    }
    for (const child of childrenToRemove) {
        node.yoga.removeChild(child);
        child.free();
    }
    node.parts = [];
    const wrap = node.parent.wrap;
    node.yoga.setFlexDirection(yoga.FLEX_DIRECTION_ROW);
    node.yoga.setFlexWrap(wrap ? yoga.WRAP_WRAP : yoga.WRAP_NO_WRAP);
    const spans = ansi_1.parseAnsi(node.value, wrap);
    for (const span of spans) {
        const part = createTextNodePart(span);
        node.parts.push(part);
        node.yoga.insertChild(part.yoga, node.yoga.getChildCount());
    }
}
exports.updateTextNodeLayout = updateTextNodeLayout;
function createTextNodePart(span) {
    const part = {
        span,
        yoga: yoga.Node.create(),
    };
    const width = string_width_1.default(span.value);
    part.yoga.setWidth(width);
    part.yoga.setHeight(1);
    part.yoga.setMinHeight(1);
    return part;
}
function createTextNode(text) {
    const node = {
        type: "text",
        parent: null,
        parts: [],
        value: text,
        yoga: yoga.Node.create(),
    };
    node.yoga.setFlexWrap(yoga.WRAP_WRAP);
    return node;
}
exports.createTextNode = createTextNode;
function removeChildNode(node, child) {
    child.parent = null;
    const index = node.children.indexOf(child);
    if (index >= 0) {
        node.children.splice(index, 1);
        const yoga = node.yoga.getChild(index);
        node.yoga.removeChild(yoga);
    }
    if (child.type === "text") {
        updateTextNodeLayout(child);
    }
}
exports.removeChildNode = removeChildNode;
function appendChildNode(node, child) {
    if (child.parent) {
        removeChildNode(child.parent, child);
        child.parent.yoga.removeChild(child.yoga);
    }
    child.parent = node;
    node.children.push(child);
    node.yoga.insertChild(child.yoga, node.yoga.getChildCount());
    if (child.type === "text") {
        updateTextNodeLayout(child);
    }
}
exports.appendChildNode = appendChildNode;
function insertBeforeNode(node, child, before) {
    if (child.parent) {
        removeChildNode(child.parent, child);
        child.parent.yoga.removeChild(child.yoga);
    }
    child.parent = node;
    const index = node.children.indexOf(before);
    if (index >= 0) {
        node.children.splice(index, 0, child);
        node.yoga.insertChild(child.yoga, index);
    }
    else {
        node.children.push(child);
        node.yoga.insertChild(child.yoga, node.yoga.getChildCount());
    }
    if (child.type === "text") {
        updateTextNodeLayout(child);
    }
}
exports.insertBeforeNode = insertBeforeNode;
function applyAttributes(node, attributes) {
    node.attributes = { ...attributes };
    if (node.attributes.style) {
        style_1.applyStyle(node.yoga, node.attributes.style);
    }
    else {
        style_1.applyStyle(node.yoga, {});
    }
    node.drawOffsetTop = node.attributes.drawOffsetTop;
    node.drawOffsetLeft = node.attributes.drawOffsetLeft;
    node.drawOverflow =
        typeof node.attributes.drawOverflow !== "undefined"
            ? node.attributes.drawOverflow
            : true;
    node.color = node.attributes.color;
    node.bg = node.attributes.bg;
    node.wrap = Boolean(node.attributes.wrap);
    node.onClick = node.attributes.onClick;
    node.onMouse = node.attributes.onMouse;
}
exports.applyAttributes = applyAttributes;
function getNodesContainingPosition(node, positionX, positionY) {
    const nodes = [];
    forAllComplexChildren(node, (n, x, y) => {
        const width = n.yoga.getComputedWidth();
        const height = n.yoga.getComputedHeight();
        const xmin = x;
        const xmax = x + width - 1;
        const ymin = y;
        const ymax = y + height - 1;
        if (positionX >= xmin &&
            positionX <= xmax &&
            positionY >= ymin &&
            positionY <= ymax) {
            nodes.push(n);
        }
    });
    return nodes;
}
exports.getNodesContainingPosition = getNodesContainingPosition;
//# sourceMappingURL=dom.js.map