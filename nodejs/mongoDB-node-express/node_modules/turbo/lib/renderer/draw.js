"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const dom_1 = require("./dom");
const yoga = __importStar(require("yoga-layout-prebuilt"));
function getAbsoluteLayout(node) {
    let top = 0, left = 0;
    let n = node;
    while (n !== null) {
        top += n.yoga.getComputedTop();
        left += n.yoga.getComputedLeft();
        n = n.parent;
    }
    const width = node.yoga.getComputedWidth();
    const height = node.yoga.getComputedHeight();
    return { top, left, width, height };
}
function normalizeSpanColor(color, bgColor, span) {
    const normalColor = typeof color !== "undefined" ? color : span.color;
    const normalBgColor = typeof bgColor !== "undefined" ? bgColor : span.bgColor;
    return {
        color: normalColor,
        defaultColor: typeof normalColor === "undefined",
        bgColor: normalBgColor,
        bgDefaultColor: typeof normalBgColor === "undefined",
        bold: span.bold,
        dim: span.dim,
        italic: span.italic,
        underline: span.underline,
        blink: span.blink,
        inverse: span.inverse,
        strike: span.strike,
    };
}
function drawNode(node, offsetX, offsetY, container) {
    const { target } = container;
    const x = offsetX + node.yoga.getComputedLeft();
    const y = offsetY + node.yoga.getComputedTop();
    let xmin = 0, xmax = 0, ymin = 0, ymax = 0, drawOffsetTop = 0, drawOffsetLeft = 0;
    const boundingParent = dom_1.findClosestParent(node, n => n.drawOverflow === false);
    if (!boundingParent) {
        xmin = x;
        xmax = x + node.yoga.getComputedWidth() - 1;
        ymin = y;
        ymax = y + node.yoga.getComputedHeight() - 1;
    }
    else {
        const boundingLayout = getAbsoluteLayout(boundingParent);
        xmin = boundingLayout.left;
        xmax = boundingLayout.left + boundingLayout.width - 1;
        ymin = boundingLayout.top;
        ymax = boundingLayout.top + boundingLayout.height - 1;
    }
    const drawOffsetTopParent = dom_1.findClosestParent(node, n => n.drawOffsetTop !== undefined);
    if (drawOffsetTopParent) {
        drawOffsetTop = drawOffsetTopParent.drawOffsetTop || 0;
    }
    const drawOffsetLeftParent = dom_1.findClosestParent(node, n => n.drawOffsetLeft !== undefined);
    if (drawOffsetLeftParent) {
        drawOffsetLeft = drawOffsetLeftParent.drawOffsetLeft || 0;
    }
    if (node.type === "text" && node.parent) {
        const color = dom_1.resolveProperty(node, n => n.color);
        const bg = dom_1.resolveProperty(node, n => n.bg);
        for (const part of node.parts) {
            const partX = x + part.yoga.getComputedLeft();
            const partY = y + part.yoga.getComputedTop();
            target.draw(partX + drawOffsetLeft, partY + drawOffsetTop, xmin, xmax, ymin, ymax, normalizeSpanColor(color, bg, part.span), part.span.value);
        }
    }
    else if (node.type !== "text") {
        if (node.attributes["unstable_moveCursorToThisPosition"]) {
            const cursorX = x + drawOffsetLeft;
            const cursorY = y + drawOffsetTop;
            if (cursorX >= xmin &&
                cursorX <= xmax &&
                cursorY >= ymin &&
                cursorY <= ymax) {
                target.setCursor(cursorX, cursorY);
            }
            else {
                target.clearCursor();
            }
        }
        if (node.bg !== undefined) {
            target.fillBg(xmin, xmax, ymin, ymax, node.bg);
        }
        for (const child of node.children) {
            drawNode(child, x, y, container);
        }
    }
}
function drawContainer(container) {
    const { node, target } = container;
    const { width, height } = target;
    if (container.drawing) {
        throw new Error("container still drawing");
    }
    container.drawing = true;
    let delta = true;
    if (container.forceRedraw) {
        container.forceRedraw = false;
        delta = false;
    }
    dom_1.forAllTextChildren(node, dom_1.updateTextNodeLayout);
    node.yoga.setWidth(width);
    if (typeof height !== "undefined") {
        node.yoga.setHeight(height);
    }
    else {
        node.yoga.setHeightAuto();
    }
    for (const child of node.children) {
        child.yoga.setWidth(width);
        if (typeof height !== "undefined") {
            child.yoga.setHeight(height);
        }
        else {
            child.yoga.setHeightAuto();
        }
    }
    const direction = yoga.DIRECTION_LTR;
    node.yoga.calculateLayout(width, height, direction);
    const x = node.yoga.getComputedLeft();
    const y = node.yoga.getComputedTop();
    const realWidth = node.yoga.getComputedWidth();
    const realHeight = node.yoga.getComputedHeight();
    target.prepare(realWidth, realHeight);
    drawNode(node, x, y, container);
    target.flush(delta);
    container.drawing = false;
}
exports.drawContainer = drawContainer;
//# sourceMappingURL=draw.js.map