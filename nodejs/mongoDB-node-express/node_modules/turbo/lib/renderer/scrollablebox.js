"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const _1 = require(".");
const _2 = require(".");
function useSize(ref) {
    const [width, setWidth] = react_1.default.useState(0);
    const [height, setHeight] = react_1.default.useState(0);
    react_1.default.useEffect(() => {
        if (ref.current) {
            const newWidth = ref.current.yoga.getComputedWidth();
            const newHeight = ref.current.yoga.getComputedHeight();
            setWidth(newWidth);
            setHeight(newHeight);
        }
        else {
            setWidth(0);
            setHeight(0);
        }
    });
    return {
        width,
        height,
    };
}
function ScrollableBox(props) {
    const contentRef = react_1.default.useRef();
    const viewportRef = react_1.default.useRef();
    const viewport = useSize(viewportRef);
    const shouldSnapToBottom = props.snapToBottom || false;
    const [desiredFocus, setDesiredFocus] = react_1.default.useState(props.desiredFocus);
    const [contentHeight, setContentHeight] = react_1.default.useState(0);
    const [viewportOffset, setViewportOffset] = react_1.default.useState(0);
    const [snappedToBottom, setSnappedToBottom] = react_1.default.useState(props.snapToBottom);
    const [barHeight, setBarHeight] = react_1.default.useState(0);
    const minViewportOffset = 0;
    const maxViewportOffset = Math.max(0, contentHeight - viewport.height);
    react_1.default.useEffect(() => {
        if (contentRef.current && viewport.width !== 0) {
            const height = _2.unstable_calculateTextHeight(contentRef.current, viewport.width);
            setContentHeight(height);
        }
    });
    react_1.default.useEffect(() => {
        updateViewportOffset(viewportOffset, false);
        updateBarHeight();
    }, [viewport.height, contentHeight, props.desiredFocus]);
    function updateViewportOffset(offset, userInteraction) {
        const firstLine = contentHeight - viewportOffset;
        const lastLine = firstLine + viewport.height;
        const oldDesiredFocus = desiredFocus;
        const newDesiredFocus = props.desiredFocus;
        const desiredFocusInView = typeof props.desiredFocus !== "undefined"
            ? props.desiredFocus >= firstLine &&
                props.desiredFocus <= lastLine
            : true;
        let newOffset = offset;
        if (!desiredFocusInView && oldDesiredFocus !== newDesiredFocus) {
            newOffset =
                (newDesiredFocus || 0) - Math.floor(viewport.height / 2);
        }
        else if (snappedToBottom && !userInteraction) {
            newOffset = maxViewportOffset;
        }
        if (newOffset < minViewportOffset) {
            newOffset = minViewportOffset;
        }
        else if (newOffset > maxViewportOffset) {
            newOffset = maxViewportOffset;
        }
        if (shouldSnapToBottom && newOffset === maxViewportOffset) {
            setViewportOffset(maxViewportOffset);
            setSnappedToBottom(true);
        }
        else {
            const shouldUnsnap = userInteraction && newOffset !== viewportOffset;
            setSnappedToBottom(shouldUnsnap);
            setViewportOffset(newOffset);
        }
        setDesiredFocus(newDesiredFocus);
    }
    function updateBarHeight() {
        if (viewport.height !== 0 &&
            contentHeight !== 0 &&
            viewport.height < contentHeight) {
            setBarHeight(Math.ceil(viewport.height * (viewport.height / contentHeight)));
        }
        else {
            setBarHeight(0);
        }
    }
    function onMouse(event) {
        if (event.button === "wheel-up") {
            updateViewportOffset(viewportOffset - 4, true);
        }
        else if (event.button === "wheel-down") {
            updateViewportOffset(viewportOffset + 4, true);
        }
    }
    const viewportPercent = viewportOffset / maxViewportOffset;
    return (react_1.default.createElement(_1.Box, { grow: props.grow, shrink: props.shrink, basis: props.basis, height: props.height, width: props.width, minHeight: props.height, maxHeight: props.height, minWidth: props.width, maxWidth: props.width, marginTop: props.marginTop, marginBottom: props.marginBottom, marginLeft: props.marginLeft, marginRight: props.marginRight, drawOffsetTop: props.drawOffsetTop, drawOffsetLeft: props.drawOffsetLeft, drawOverflow: false, ref: viewportRef, onClick: props.onClick, onMouse: onMouse },
        react_1.default.createElement(_1.Box, { grow: 1, direction: props.direction, alignItems: props.alignItems, justify: props.justify, color: props.color, bg: props.bg, wrap: props.wrap, drawOffsetTop: -viewportOffset, ref: contentRef }, props.children),
        react_1.default.createElement(_1.Box, { width: 1, direction: "column", marginTop: Math.ceil(viewportPercent * (viewport.height - barHeight)) }, Array(barHeight).fill("â”ƒ"))));
}
exports.ScrollableBox = ScrollableBox;
//# sourceMappingURL=scrollablebox.js.map