"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const react_reconciler_1 = __importDefault(require("react-reconciler"));
const dom_1 = require("./dom");
const draw_1 = require("./draw");
const buffertarget_1 = require("./buffertarget");
const terminal_1 = require("./terminal");
const core_1 = require("@turbo/core");
const HostConfig = {
    isPrimaryRenderer: true,
    now: Date.now,
    setTimeout: setTimeout,
    clearTimeout: clearTimeout,
    noTimeout: -1,
    scheduleDeferredCallback(callback, options) {
        return setTimeout(callback, options ? options.timeout : 0);
    },
    cancelDeferredCallback(callbackID) {
        clearTimeout(callbackID);
    },
    supportsHydration: false,
    supportsPersistence: false,
    getPublicInstance(node) {
        return node;
    },
    getRootHostContext(_container) {
        return true;
    },
    getChildHostContext(_, __, ___) {
        return true;
    },
    shouldSetTextContent(_, __) {
        return false;
    },
    createTextInstance(text, _container, _hostContext) {
        return dom_1.createTextNode(text);
    },
    createInstance(type, props, _container, ___) {
        const instance = dom_1.createNode(type);
        dom_1.applyAttributes(instance, props);
        return instance;
    },
    appendInitialChild: dom_1.appendChildNode,
    finalizeInitialChildren(_parentInstance, _type, _props, _rootContainerInstance, _hostContext) {
        return false;
    },
    prepareForCommit(_) {
        return undefined;
    },
    resetAfterCommit(container) {
        draw_1.drawContainer(container);
    },
    appendChildToContainer(container, child) {
        dom_1.appendChildNode(container.node, child);
    },
    supportsMutation: true,
    commitMount(_instance, _type, _newProps) {
        return undefined;
    },
    prepareUpdate(_instance, _type, _oldProps, _newProps, rootContainerInstance, _hostContext) {
        return rootContainerInstance;
    },
    commitUpdate(instance, updatePayload, _type, _oldProps, newProps) {
        dom_1.applyAttributes(instance, newProps);
    },
    commitTextUpdate(instance, _oldText, newText) {
        instance.value = newText;
    },
    appendChild: dom_1.appendChildNode,
    insertBefore: dom_1.insertBeforeNode,
    removeChild: dom_1.removeChildNode,
    insertInContainerBefore(container, child, before) {
        dom_1.insertBeforeNode(container.node, child, before);
    },
    removeChildFromContainer(container, child) {
        dom_1.removeChildNode(container.node, child);
    },
    resetTextContent(_) {
        return undefined;
    },
    shouldDeprioritizeSubtree() {
        return false;
    },
};
const reconcilerInstance = react_reconciler_1.default(HostConfig);
function unstable_batchedUpdates(cb) {
    return reconcilerInstance.batchedUpdates(cb);
}
exports.unstable_batchedUpdates = unstable_batchedUpdates;
function render(element, mode = "fullscreen", callback) {
    const target = new terminal_1.TerminalBufferTarget(mode);
    const isAsync = false;
    const shouldHydrate = false;
    target.setup();
    const container = dom_1.createContainer(target);
    const root = reconcilerInstance.createContainer(container, isAsync, shouldHydrate);
    const parentComponent = null;
    const rootElement = react_1.default.createElement(buffertarget_1.BufferTargetContext.Provider, {
        value: target,
    }, element);
    function doRender(doCallback) {
        unstable_batchedUpdates(() => {
            reconcilerInstance.updateContainer(rootElement, root, parentComponent, doCallback && callback ? callback : () => undefined);
        });
    }
    target.on("resize", () => {
        container.forceRedraw = true;
        doRender(false);
    });
    target.on("mouse", event => {
        const { x, y } = event;
        const targets = dom_1.getNodesContainingPosition(container.node, x - 1, y - 1);
        for (const target of targets) {
            if (event.button === "left" && !event.pressed && target.onClick) {
                core_1.logger.verbose("handling target onClick");
                target.onClick(event);
            }
            if (target.onMouse) {
                target.onMouse(event);
            }
        }
    });
    doRender(true);
}
exports.render = render;
//# sourceMappingURL=renderer.js.map