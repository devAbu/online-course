"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const buffertarget_1 = require("./buffertarget");
const terminal_kit_1 = require("terminal-kit");
const core_1 = require("@turbo/core");
const renderer_1 = require("./renderer");
function showAlternateScreen() {
    process.stdout.write(Buffer.from([0x1b, 0x5b, 0x3f, 0x31, 0x30, 0x34, 0x39, 0x68]));
}
function hideAlternateScreen() {
    process.stdout.write(Buffer.from([0x1b, 0x5b, 0x3f, 0x31, 0x30, 0x34, 0x39, 0x6c]));
}
function normalizeMouseEvent(type, event) {
    let pressed = false;
    let button = "left";
    switch (type) {
        case "MOUSE_LEFT_BUTTON_RELEASED":
            pressed = false;
            button = "left";
            break;
        case "MOUSE_LEFT_BUTTON_PRESSED":
            pressed = true;
            button = "left";
            break;
        case "MOUSE_RIGHT_BUTTON_RELEASED":
            pressed = false;
            button = "right";
            break;
        case "MOUSE_RIGHT_BUTTON_PRESSED":
            pressed = true;
            button = "right";
            break;
        case "MOUSE_MIDDLE_BUTTON_RELEASED":
            pressed = false;
            button = "middle";
            break;
        case "MOUSE_MIDDLE_BUTTON_PRESSED":
            pressed = true;
            button = "middle";
            break;
        case "MOUSE_OTHER_BUTTON_RELEASED":
            pressed = false;
            button = "other";
            break;
        case "MOUSE_OTHER_BUTTON_PRESSED":
            pressed = true;
            button = "other";
            break;
        case "MOUSE_WHEEL_UP":
            pressed = false;
            button = "wheel-up";
            break;
        case "MOUSE_WHEEL_DOWN":
            pressed = false;
            button = "wheel-down";
            break;
    }
    return {
        x: event.x,
        y: event.y,
        pressed,
        button,
    };
}
function normalizeName(name, matches) {
    function stripMods(str) {
        return str
            .replace(/CTRL_/g, "")
            .replace(/ALT_/g, "")
            .replace(/SHIFT_/g, "");
    }
    function getMods(str) {
        return {
            ctrl: str.includes("CTRL_"),
            alt: str.includes("ALT_"),
            shift: str.includes("SHIFT_"),
        };
    }
    const cleanName = stripMods(name);
    if (buffertarget_1.SPECIAL_KEYS.includes(cleanName)) {
        const { ctrl, alt, shift } = getMods(name);
        return {
            key: cleanName,
            ctrl,
            alt,
            shift,
        };
    }
    for (const match of matches) {
        const cleanMatch = stripMods(match);
        if (buffertarget_1.SPECIAL_KEYS.includes(cleanMatch)) {
            const { ctrl, alt, shift } = getMods(match);
            return {
                key: cleanMatch,
                ctrl,
                alt,
                shift,
            };
        }
    }
    const { ctrl, alt, shift } = getMods(name);
    return {
        key: cleanName,
        ctrl,
        alt,
        shift,
    };
}
class TerminalBufferTarget extends core_1.EmitterBase {
    constructor(mode) {
        super();
        this.buffer = new terminal_kit_1.ScreenBuffer({
            dst: terminal_kit_1.terminal,
        });
        this.cursor = null;
        this.width = 0;
        this.height = 0;
        this.mode = mode;
    }
    setup() {
        if (this.mode === "fullscreen") {
            this.width = terminal_kit_1.terminal.width;
            this.height = terminal_kit_1.terminal.height;
            process.stdin.on("data", data => {
                const str = data.toString();
                if (str === "\x03") {
                    process.exit(0);
                }
            });
            process.on("exit", () => {
                hideAlternateScreen();
            });
            showAlternateScreen();
            terminal_kit_1.terminal.grabInput({ mouse: "button" });
            terminal_kit_1.terminal.on("resize", (width, height) => {
                this.width = width;
                this.height = height;
                this.buffer.resize({
                    xmin: 0,
                    xmax: width,
                    ymin: 0,
                    ymax: height,
                });
                terminal_kit_1.terminal.clear();
                this.fire("resize", undefined);
            });
        }
        else {
            this.width = terminal_kit_1.terminal.width;
            this.height = undefined;
        }
        terminal_kit_1.terminal.on("mouse", (type, data) => {
            renderer_1.unstable_batchedUpdates(() => {
                this.fire("mouse", normalizeMouseEvent(type, data));
            });
        });
        terminal_kit_1.terminal.on("key", (name, matches, data) => {
            renderer_1.unstable_batchedUpdates(() => {
                const { key, ctrl, alt, shift } = normalizeName(name, matches);
                if (data.isCharacter) {
                    this.fire("input", {
                        isChar: true,
                        name: key,
                        ctrl,
                        alt,
                        shift,
                        char: key,
                        codepoint: data.codepoint || 0,
                    });
                }
                else {
                    this.fire("input", {
                        isChar: false,
                        name: key,
                        ctrl,
                        alt,
                        shift,
                    });
                }
            });
        });
    }
    fillBg(xmin, xmax, ymin, ymax, color) {
        this.buffer.fill({
            attr: {
                bgColor: color,
            },
            region: {
                xmin,
                xmax,
                ymin,
                ymax,
            },
        });
    }
    draw(x, y, xmin, xmax, ymin, ymax, attr, str) {
        const dx = 1;
        const dy = 0;
        let targetX = x;
        let targetY = y;
        for (const c of str) {
            if (targetX >= xmin &&
                targetX <= xmax &&
                targetY >= ymin &&
                targetY <= ymax) {
                this.buffer.put({
                    dx: 0,
                    dy: 0,
                    x: targetX,
                    y: targetY,
                    attr: attr,
                    wrap: false,
                }, c);
            }
            targetX += dx;
            targetY += dy;
        }
    }
    setCursor(x, y) {
        this.cursor = { x, y };
    }
    clearCursor() {
        this.cursor = null;
    }
    prepare(width, height) {
        if (this.width !== width || this.height !== height) {
            this.buffer.resize({ width, height, x: 0, y: 0 });
        }
        this.buffer.fill({
            attr: {
                bgDefaultColor: true,
            },
        });
    }
    flush(delta) {
        if (this.mode === "fullscreen") {
            this.buffer.draw({ delta });
            if (this.cursor) {
                terminal_kit_1.terminal.hideCursor(false);
                this.buffer.moveTo(this.cursor.x, this.cursor.y);
                this.buffer.drawCursor();
            }
            else {
                terminal_kit_1.terminal.hideCursor();
                this.buffer.drawCursor();
            }
        }
        else {
            const output = this.buffer.dumpChars();
            process.stdout.write(output);
        }
    }
}
exports.TerminalBufferTarget = TerminalBufferTarget;
//# sourceMappingURL=terminal.js.map