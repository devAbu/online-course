"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const process_1 = __importDefault(require("process"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const child_process_1 = __importDefault(require("child_process"));
const os_1 = __importDefault(require("os"));
const json5_1 = __importDefault(require("json5"));
function getVar(name) {
    return process_1.default.env ? process_1.default.env[name] : undefined;
}
function execSync(command) {
    return child_process_1.default.execSync(command).toString();
}
function ensureFolderExists(folder) {
    if (!fs_1.default.existsSync(folder)) {
        fs_1.default.mkdirSync(folder, { recursive: true });
    }
}
function getTmpFolder(context) {
    const folder = `/tmp/turbo/${context}`;
    ensureFolderExists(folder);
    return folder;
}
function getTmpFile(context, name) {
    const folder = getTmpFolder(context);
    return path_1.default.join(folder, name);
}
function getAllSessionIds() {
    const folder = getTmpFolder("sessions");
    const files = fs_1.default.readdirSync(folder);
    return files.map(f => path_1.default.basename(f));
}
function cleanPath(p) {
    const cwd = process_1.default.cwd();
    const relative = path_1.default.relative(cwd, p);
    const isSubDir = relative && !relative.startsWith("..") && !path_1.default.isAbsolute(relative);
    if (isSubDir) {
        return relative;
    }
    else {
        return p;
    }
}
function exit() {
    process_1.default.exit(0);
}
function tryRequire(path) {
    try {
        const mod = require(path);
        if (mod.__esModule) {
            return mod;
        }
        else {
            return { default: mod };
        }
    }
    catch (e) {
        if (e.code !== "MODULE_NOT_FOUND") {
            throw e;
        }
        return false;
    }
}
function turboRequire(path) {
    let mod = tryRequire(`@turbo/${path}`);
    if (mod)
        return mod;
    mod = tryRequire(path);
    if (mod)
        return mod;
    return false;
}
function readFile(path) {
    return fs_1.default.readFileSync(path).toString();
}
function getEnvironment() {
    const nodePath = process_1.default.argv[0];
    const scriptPath = process_1.default.argv[1];
    return {
        nodePath,
        scriptPath,
        getVar,
        execSync,
        getTmpFolder,
        getTmpFile,
        getAllSessionIds,
        cleanPath,
        require: turboRequire,
        readFile,
        exit,
    };
}
function loadJson(path) {
    const text = fs_1.default.readFileSync(path).toString();
    return json5_1.default.parse(text);
}
const DEFAULT_CONFIG = {
    target: "node",
    shell: "tmux",
};
function getConfig() {
    const fileName = "turbo.config.json";
    const home = os_1.default.homedir();
    const config = { ...DEFAULT_CONFIG };
    const homeFile = path_1.default.join(home, "." + fileName);
    if (fs_1.default.existsSync(homeFile)) {
        const data = loadJson(homeFile);
        Object.assign(config, data);
    }
    let dir = process_1.default.cwd();
    const root = path_1.default.parse(dir).root;
    while (true) {
        const file = path_1.default.join(dir, fileName);
        if (fs_1.default.existsSync(file)) {
            const data = loadJson(file);
            Object.assign(config, data);
        }
        if (dir === root) {
            break;
        }
        else {
            dir = path_1.default.join(dir, "..");
        }
    }
    return config;
}
function getTurbo(options) {
    const env = getEnvironment();
    const config = getConfig();
    return {
        env,
        config,
        options,
    };
}
exports.getTurbo = getTurbo;
//# sourceMappingURL=turbo.js.map