declare type EmitterCallback<T> = (event: T) => void;
export interface Emitter<T> {
    on<N extends keyof T>(name: N, func: EmitterCallback<T[N]>): void;
    once<N extends keyof T>(name: N, func: EmitterCallback<T[N]>): void;
    off<N extends keyof T>(name: N, func: EmitterCallback<T[N]>): void;
    clear<N extends keyof T>(name: N): void;
    fire<N extends keyof T>(name: N, event: T[N]): void;
}
export declare abstract class EmitterBase<T> implements Emitter<T> {
    private map;
    private mapOnce;
    once<N extends keyof T>(name: N, func: EmitterCallback<T[N]>): void;
    on<N extends keyof T>(name: N, func: EmitterCallback<T[N]>): void;
    off<N extends keyof T>(name: N, func: EmitterCallback<T[N]>): void;
    clear<N extends keyof T>(name: N): void;
    fire<N extends keyof T>(name: N, event: T[N]): void;
}
export {};
