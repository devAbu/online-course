"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const redux_1 = require("redux");
const redux_saga_1 = __importDefault(require("redux-saga"));
const sagas_1 = require("./sagas");
const _1 = require(".");
function pushed(arr, v) {
    return [...arr, v];
}
function isSameBreakLocation(a, b) {
    return a.url === b.url && a.line === b.line && a.column === b.column;
}
function unvalidateBreakpoints(breakpoints) {
    return breakpoints.filter(b => ({
        ...b,
        raw: undefined,
    }));
}
function getScriptById(scripts, id) {
    return scripts.find(s => s.id === id);
}
function reduce(initialState, state, action) {
    if (!state)
        return initialState;
    switch (action.type) {
        case "connected":
            return {
                ...state,
                target: {
                    ...state.target,
                    connected: true,
                    paused: false,
                    breakpointsEnabled: true,
                    breakpoints: unvalidateBreakpoints(state.target.breakpoints),
                    callFrames: undefined,
                    scripts: [],
                    focusedCallFrame: 0,
                },
            };
        case "disconnected":
            return {
                ...state,
                target: {
                    ...state.target,
                    connected: false,
                    paused: false,
                    breakpoints: unvalidateBreakpoints(state.target.breakpoints),
                    callFrames: undefined,
                    scripts: [],
                    focusedCallFrame: 0,
                },
            };
        case "paused":
            return {
                ...state,
                target: {
                    ...state.target,
                    paused: true,
                    callFrames: action.callFrames,
                    focusedCallFrame: 0,
                },
            };
        case "resumed":
            return {
                ...state,
                target: {
                    ...state.target,
                    paused: false,
                    callFrames: undefined,
                    focusedCallFrame: 0,
                },
            };
        case "add-script":
            return {
                ...state,
                target: {
                    ...state.target,
                    scripts: pushed(state.target.scripts, action.script),
                },
            };
        case "set-breakpoint":
            const breakpoint = action.breakpoint;
            const breakpointExists = state.target.breakpoints.some(b => isSameBreakLocation(breakpoint, b));
            if (breakpointExists)
                return state;
            return {
                ...state,
                target: {
                    ...state.target,
                    breakpoints: pushed(state.target.breakpoints, breakpoint),
                },
            };
        case "verify-breakpoint":
            const verifiedBreakpoint = action.breakpoint;
            if (!verifiedBreakpoint.raw)
                return state;
            const location = verifiedBreakpoint.raw.location;
            const script = getScriptById(state.target.scripts, location.scriptId);
            if (script) {
                const breakpoints = state.target.breakpoints;
                return {
                    ...state,
                    target: {
                        ...state.target,
                        breakpoints: breakpoints.map(b => b.id === verifiedBreakpoint.id
                            ? { ...verifiedBreakpoint }
                            : b),
                    },
                };
            }
            else {
                _1.logger.error(`received verify-breakpoint action with unknown script id ${location.scriptId}`);
                return state;
            }
        case "removed-b":
            return {
                ...state,
                target: {
                    ...state.target,
                    breakpoints: state.target.breakpoints.filter(b => b.id !== action.id),
                },
            };
        case "set-b-enable":
            return {
                ...state,
                target: {
                    ...state.target,
                    breakpointsEnabled: action.enabled,
                },
            };
        case "focus-up":
            return {
                ...state,
                target: {
                    ...state.target,
                    focusedCallFrame: state.target.paused
                        ? Math.min(state.target.focusedCallFrame + 1, state.target.callFrames.length - 1)
                        : state.target.focusedCallFrame,
                },
            };
        case "focus-down":
            return {
                ...state,
                target: {
                    ...state.target,
                    focusedCallFrame: state.target.paused
                        ? Math.max(state.target.focusedCallFrame - 1, 0)
                        : state.target.focusedCallFrame,
                },
            };
        case "focus":
            let newFocus = state.target.focusedCallFrame;
            if (state.target.paused &&
                newFocus >= 0 &&
                newFocus < state.target.callFrames.length) {
                newFocus = action.frame;
            }
            return {
                ...state,
                target: {
                    ...state.target,
                    focusedCallFrame: newFocus,
                },
            };
        default:
            return state;
    }
}
function makeStore(turbo, server, target, state) {
    const sagaMiddleware = redux_saga_1.default();
    const store = redux_1.createStore(reduce.bind(null, state), redux_1.applyMiddleware(sagaMiddleware));
    sagaMiddleware.run(sagas_1.rootSaga, turbo, server, target);
    return store;
}
exports.makeStore = makeStore;
//# sourceMappingURL=reducer.js.map