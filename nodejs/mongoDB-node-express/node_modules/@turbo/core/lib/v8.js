"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chrome_remote_interface_1 = __importDefault(require("chrome-remote-interface"));
const index_1 = require("./index");
const CDP = chrome_remote_interface_1.default;
function toSourceLocation(location) {
    return {
        scriptId: location.scriptId,
        line: location.lineNumber,
        column: location.columnNumber,
    };
}
function toBreakLocation(location) {
    return {
        scriptId: location.scriptId,
        line: location.lineNumber,
        column: location.columnNumber,
        type: location.type,
    };
}
function toScript(script) {
    return {
        id: script.scriptId,
        url: index_1.canonicalizeUrl(script.url),
        rawUrl: script.url,
        startLine: script.startLine,
        startColumn: script.startColumn,
        endLine: script.endLine,
        endColumn: script.endColumn,
        hash: script.hash,
        isLiveEdit: script.isLiveEdit,
        sourceMapUrl: script.sourceMapURL,
        hasSourceUrl: script.hasSourceURL,
        isModule: script.isModule,
        length: script.length,
    };
}
function toScope(scope) {
    return {
        type: scope.type,
        object: toRemoteObject(scope.object),
        name: scope.name,
        startLocation: scope.startLocation
            ? toSourceLocation(scope.startLocation)
            : undefined,
        endLocation: scope.endLocation
            ? toSourceLocation(scope.endLocation)
            : undefined,
    };
}
function toCallFrame(callFrame) {
    return {
        id: callFrame.callFrameId,
        functionName: callFrame.functionName,
        location: toSourceLocation(callFrame.location),
        scopes: callFrame.scopeChain.map(s => toScope(s)),
    };
}
function toRemoteObject(obj) {
    if (obj.type === "string") {
        return { type: "string", value: obj.value };
    }
    else if (obj.type === "number") {
        return {
            type: "number",
            value: obj.value,
            description: obj.description || "",
        };
    }
    else if (obj.type === "boolean") {
        return { type: "boolean", value: obj.value };
    }
    else if (obj.type === "symbol") {
        return {
            type: "symbol",
            description: obj.description || "",
            objectId: (obj.objectId || ""),
        };
    }
    else if (obj.type === "bigint") {
        return {
            type: "bigint",
            value: obj.unserializableValue || "",
            description: obj.description || "",
        };
    }
    else if (obj.type === "undefined") {
        return { type: "undefined" };
    }
    else if (obj.type === "function") {
        return {
            type: "function",
            className: obj.className || "",
            description: obj.description || "",
            objectId: (obj.objectId || ""),
        };
    }
    else if (obj.type === "object") {
        return {
            type: "object",
            className: obj.className || "",
            subtype: obj.subtype || "",
            description: obj.description || "",
            objectId: (obj.objectId || ""),
        };
    }
    else {
        throw new Error("unknown v8 type: " + obj.type);
    }
}
function toRemoteObjectProperty(obj) {
    return {
        name: obj.name,
        value: obj.value ? toRemoteObject(obj.value) : { type: "undefined" },
        writable: obj.writable || false,
        get: obj.get ? toRemoteObject(obj.get) : undefined,
        set: obj.set ? toRemoteObject(obj.set) : undefined,
        configurable: obj.configurable,
        enumerable: obj.enumerable,
        isOwn: obj.isOwn || false,
        symbol: obj.symbol ? toRemoteObject(obj.symbol) : undefined,
    };
}
function toRemoteException(obj) {
    return {
        text: obj.text,
        line: obj.lineNumber,
        column: obj.columnNumber,
        scriptId: obj.scriptId,
        url: obj.url,
        exception: obj.exception ? toRemoteObject(obj.exception) : undefined,
    };
}
class V8TargetConnection extends index_1.EmitterBase {
    constructor(client, breakpoints) {
        super();
        this.scripts = new Map();
        this.breakpoints = new Map();
        this.callFrames = null;
        this.enabled = false;
        this.needsResume = false;
        this._breakpointsEnabled = false;
        this.client = client;
        for (const breakpoint of breakpoints) {
            this.breakpoints.set(breakpoint.id, {
                ...breakpoint,
                raw: undefined,
            });
        }
    }
    get breakpointsEnabled() {
        return this._breakpointsEnabled;
    }
    async setup() {
        let first = true;
        this.client.on("disconnect", () => {
            index_1.logger.debug("v8 disconnect event");
            this.fire("close", undefined);
        });
        this.client.on("error", (error) => {
            index_1.logger.error(error.toString());
        });
        this.client.Debugger.paused(event => {
            if (first) {
                first = false;
                index_1.logger.debug("v8 first break received");
                if (this.enabled) {
                    index_1.logger.debug("resuming after first break");
                    this.client.Debugger.resume();
                }
                else {
                    index_1.logger.debug("deferring resume until enabled");
                    this.needsResume = true;
                }
            }
            else {
                index_1.logger.debug("v8 target paused");
                this.callFrames = event.callFrames;
                this.fire("paused", {
                    callFrames: event.callFrames.map(toCallFrame),
                });
            }
        });
        this.client.Debugger.resumed(() => {
            this.callFrames = null;
            this.fire("resumed", undefined);
        });
        this.client.Debugger.scriptParsed(event => {
            const script = toScript(event);
            index_1.logger.verbose(`v8 script parsed ${script.id} ${script.rawUrl}`);
            this.scripts.set(script.id, script);
            this.fire("scriptParsed", { script });
        });
        this.client.Debugger.breakpointResolved(e => {
            index_1.logger.verbose(`v8 breakpoint resolved ${e.breakpointId}`);
            const location = toSourceLocation(e.location);
            const script = this.scripts.get(location.scriptId);
            if (script) {
                const matches = Array.from(this.breakpoints.values()).filter(b => b.rawUrl === script.rawUrl &&
                    b.line === location.line &&
                    (!b.column || b.column === location.column));
                if (matches.length === 1) {
                    const match = matches[0];
                    index_1.logger.verbose(`found breakpoint match: ${match.id}`);
                    const breakpoint = {
                        ...match,
                        raw: {
                            id: e.breakpointId,
                            location,
                        },
                        line: location.line,
                        column: location.column,
                    };
                    this.breakpoints.set(breakpoint.id, breakpoint);
                    this.fire("breakpointResolved", { breakpoint });
                }
                else {
                    index_1.logger.error(`unexpected number of breakpoint matches during resolve: ${matches.length}`);
                }
            }
            else {
                index_1.logger.error(`couldn't get script during breakpoint resolve ${location.scriptId}`);
            }
        });
    }
    async enable() {
        await this.client.Debugger.enable({});
        await this.client.Debugger.setBreakpointsActive({ active: true });
        this._breakpointsEnabled = false;
        for (const breakpoint of this.breakpoints.values()) {
            await this.setBreakpoint(breakpoint);
        }
        await this.client.Runtime.runIfWaitingForDebugger();
        this.enabled = true;
        if (this.needsResume) {
            index_1.logger.debug("doing deferred resume");
            await this.client.Debugger.resume();
            this.needsResume = false;
        }
    }
    async resume() {
        index_1.logger.debug("v8 resume");
        if (this.callFrames) {
            await this.client.Debugger.resume();
        }
    }
    async pause() {
        index_1.logger.debug("v8 pause");
        if (!this.callFrames) {
            await this.client.Debugger.pause();
        }
    }
    async stepInto() {
        index_1.logger.debug("v8 stepInto");
        if (this.callFrames) {
            await this.client.Debugger.stepInto({});
        }
    }
    async stepOut() {
        index_1.logger.debug("v8 stepOut");
        if (this.callFrames) {
            await this.client.Debugger.stepOut();
        }
    }
    async stepOver() {
        index_1.logger.debug("v8 stepOver");
        if (this.callFrames) {
            await this.client.Debugger.stepOver();
        }
    }
    async setBreakpoint(breakpoint) {
        index_1.logger.debug(`v8 setBreakpoint ${breakpoint.rawUrl} ${breakpoint.line}:${breakpoint.column}`);
        const { breakpointId, locations, } = await this.client.Debugger.setBreakpointByUrl({
            url: breakpoint.rawUrl,
            lineNumber: breakpoint.line,
            columnNumber: breakpoint.column,
            condition: breakpoint.condition,
        });
        index_1.logger.debug(`new breakpoint id: ${breakpointId}`);
        index_1.logger.debug(JSON.stringify(locations, null, 4));
        if (locations.length > 0) {
            const location = toSourceLocation(locations[0]);
            const newBreakpoint = {
                ...breakpoint,
                raw: {
                    id: breakpointId,
                    location,
                },
                line: location.line,
                column: location.column,
            };
            this.fire("breakpointResolved", { breakpoint: newBreakpoint });
            this.breakpoints.set(newBreakpoint.id, newBreakpoint);
        }
    }
    async removeBreakpoint(id) {
        const breakpoint = this.breakpoints.get(id);
        this.breakpoints.delete(id);
        if (breakpoint && breakpoint.raw) {
            await this.client.Debugger.removeBreakpoint({
                breakpointId: breakpoint.raw.id,
            });
        }
        else if (breakpoint) {
            index_1.logger.error(`failed to remove breakpoint ${breakpoint.id}, not resolved`);
        }
        else {
            index_1.logger.error(`failed to remove breakpoint ${id}, unknown id`);
        }
    }
    async enableBreakpoints() {
        await this.client.Debugger.setBreakpointsActive({ active: true });
        this._breakpointsEnabled = true;
    }
    async disableBreakpoints() {
        await this.client.Debugger.setBreakpointsActive({ active: false });
        this._breakpointsEnabled = false;
    }
    async getPossibleBreakpointLocations(id) {
        const { locations } = await this.client.Debugger.getPossibleBreakpoints({
            start: {
                scriptId: id,
                lineNumber: 0,
            },
        });
        return locations.map(l => toBreakLocation(l));
    }
    async eval(script, id) {
        index_1.logger.debug("v8 eval received: " + script);
        const frame = this.findCallFrame(id);
        if (frame) {
            const { result, exceptionDetails, } = await this.client.Debugger.evaluateOnCallFrame({
                expression: `(${script})`,
                callFrameId: frame.callFrameId,
            });
            if (exceptionDetails) {
                return {
                    error: true,
                    value: toRemoteException(exceptionDetails),
                };
            }
            else {
                return {
                    error: false,
                    value: toRemoteObject(result),
                };
            }
        }
        else {
            return { error: true, value: `invalid call frame: ${id}` };
        }
    }
    async getScriptSource(scriptId) {
        const { scriptSource } = await this.client.Debugger.getScriptSource({
            scriptId,
        });
        return scriptSource;
    }
    async getProperties(objectId) {
        const { result, exceptionDetails, } = await this.client.Runtime.getProperties({
            objectId,
            ownProperties: true,
        });
        if (!exceptionDetails) {
            return {
                error: false,
                value: result.map(toRemoteObjectProperty),
            };
        }
        else {
            return {
                error: true,
                value: toRemoteException(exceptionDetails),
            };
        }
    }
    async close() {
        return await this.client.close();
    }
    findCallFrame(id) {
        if (this.callFrames) {
            return this.callFrames.find(f => f.callFrameId === id) || null;
        }
        else {
            return null;
        }
    }
}
async function connect(host, port, breakpoints) {
    index_1.logger.verbose("connecting cdp");
    const client = await CDP({ host, port });
    index_1.logger.verbose("connected to cdp");
    const conn = new V8TargetConnection(client, breakpoints);
    index_1.logger.verbose("waiting for cdp setup");
    await conn.setup();
    index_1.logger.verbose("cdp is setup");
    return conn;
}
exports.connect = connect;
//# sourceMappingURL=v8.js.map