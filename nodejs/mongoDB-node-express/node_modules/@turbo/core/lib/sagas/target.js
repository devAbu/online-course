"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../index");
const redux_saga_1 = require("redux-saga");
const effects_1 = require("redux-saga/effects");
const v8_1 = require("../v8");
function setupTarget(target) {
    index_1.logger.verbose("sagas: setupTarget");
    return redux_saga_1.eventChannel(emit => {
        target.on("started", event => {
            emit({
                type: "started",
                host: event.interface.host,
                port: event.interface.port,
            });
        });
        target.on("stopped", () => {
            emit({ type: "stopped" });
        });
        index_1.logger.verbose("target setup and starting");
        target.start();
        return () => {
            index_1.logger.verbose("target being destroyed");
            target.stop();
        };
    });
}
function* setupConnection(connection) {
    index_1.logger.verbose("sagas: setupConnection");
    return redux_saga_1.eventChannel(emit => {
        index_1.logger.verbose("setting up target connection");
        connection.on("paused", event => {
            index_1.logger.verbose("sagas: target paused");
            emit({ type: "paused", callFrames: event.callFrames });
        });
        connection.on("resumed", () => {
            index_1.logger.verbose("sagas: target resumed");
            emit({ type: "resumed" });
        });
        connection.on("scriptParsed", event => {
            index_1.logger.verbose(`sagas: script parsed: ${event.script.url}`);
            emit({ type: "add-script", script: event.script });
        });
        connection.on("breakpointResolved", event => {
            index_1.logger.verbose("sagas: breakpoint resolved");
            emit({
                type: "verify-breakpoint",
                breakpoint: {
                    ...event.breakpoint,
                },
            });
        });
        connection.on("close", () => emit(redux_saga_1.END));
        return () => {
            connection.close();
        };
    });
}
function* watchConnectionRequests(target) {
    yield effects_1.takeEvery("pause", () => target.pause());
    yield effects_1.takeEvery("resume", () => target.resume());
    yield effects_1.takeEvery("stepInto", function* () {
        yield effects_1.call(() => target.stepInto());
    });
    yield effects_1.takeEvery("stepOut", function* () {
        yield effects_1.call(() => target.stepOut());
    });
    yield effects_1.takeEvery("stepOver", function* () {
        yield effects_1.call(() => target.stepOver());
    });
    yield effects_1.takeEvery("set-breakpoint", function* (action) {
        yield effects_1.call([target, target.setBreakpoint], action.breakpoint);
    });
    yield effects_1.takeEvery("remove-b-request", function* (action) {
        index_1.logger.verbose("sagas: target: remove-b-request");
        yield effects_1.call([target, target.removeBreakpoint], action.id);
        yield effects_1.put({ type: "removed-b", id: action.id });
    });
    yield effects_1.takeEvery("set-b-enable-request", function* (a) {
        if (a.enabled) {
            yield effects_1.call(() => target.enableBreakpoints());
        }
        else {
            yield effects_1.call(() => target.disableBreakpoints());
        }
        yield effects_1.put({ type: "set-b-enable", enabled: a.enabled });
    });
}
function* watchConnectionEvents(channel) {
    while (true) {
        const action = yield effects_1.take(channel);
        yield effects_1.put(action);
    }
}
function* spawnConnection(host, port, connectionChannel) {
    index_1.logger.verbose(`sagas: spawnConnection ${host}:${port}`);
    const state = yield effects_1.select();
    const connection = yield effects_1.call(v8_1.connect, host, port, state.target.breakpoints);
    const channel = yield effects_1.call(setupConnection, connection);
    yield effects_1.fork(watchConnectionRequests, connection);
    yield effects_1.fork(watchConnectionEvents, channel);
    yield effects_1.put(connectionChannel, connection);
    yield effects_1.put({ type: "connect" });
    yield effects_1.call(() => connection.enable());
}
exports.spawnConnection = spawnConnection;
function* watchTarget(channel, connectionChannel) {
    let task = null;
    while (true) {
        const action = yield effects_1.take(channel);
        index_1.logger.verbose(`watchTarget: ${action.type}`);
        if (action.type === "started") {
            if (task && task.isRunning()) {
                task.cancel();
            }
            task = yield effects_1.fork(spawnConnection, action.host, action.port, connectionChannel);
        }
        else if (action.type === "stopped") {
            if (task) {
                task.cancel();
                task = null;
            }
            yield effects_1.put(connectionChannel, -1);
            yield effects_1.put({ type: "disconnected" });
        }
        else {
            throw new Error(`unknown action type ${action["type"]}`);
        }
    }
}
exports.watchTarget = watchTarget;
function* targetFlow(target, connectionChannel) {
    index_1.logger.verbose("sagas: targetFlow");
    index_1.logger.verbose("created target");
    const channel = setupTarget(target);
    yield effects_1.takeEvery("start", () => {
        index_1.logger.verbose("sagas: watchTargetRequests: start");
        target.start();
    });
    yield effects_1.takeEvery("stop", () => {
        index_1.logger.verbose("sagas: watchTargetRequests: stop");
        target.stop();
    });
    yield effects_1.takeEvery("restart", () => {
        index_1.logger.verbose("sagas: watchTargetRequests: restart");
        if (target.isRunning) {
            target.once("stopped", () => {
                target.start();
            });
            target.stop();
        }
        else {
            target.start();
        }
    });
    yield effects_1.fork(watchTarget, channel, connectionChannel);
}
exports.targetFlow = targetFlow;
//# sourceMappingURL=target.js.map