"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const redux_saga_1 = require("redux-saga");
const effects_1 = require("redux-saga/effects");
function setupServer(turbo, server) {
    const connectionChannel = redux_saga_1.channel();
    const requestChannel = redux_saga_1.channel();
    const serverChannel = redux_saga_1.eventChannel(emit => {
        function onAction(action) {
            emit(action);
        }
        function onConnection(conn) {
            connectionChannel.put(conn);
            conn.on("close", () => {
                setTimeout(() => {
                    if (server.numConnections === 0) {
                        __1.logger.error("closing daemon because all clients disconnected");
                        onQuit();
                    }
                }, 5000);
            });
        }
        function onRequest(req) {
            requestChannel.put(req);
        }
        function onQuit() {
            server.broadcastQuit();
            emit(redux_saga_1.END);
            setTimeout(() => {
                turbo.env.exit();
            }, 1000);
        }
        server.on("action", onAction);
        server.on("connected", onConnection);
        server.on("request", onRequest);
        server.on("quit", onQuit);
        server.start();
        return () => {
            server.off("action", onAction);
            server.off("connected", onConnection);
            server.off("request", onRequest);
            server.off("quit", onQuit);
            connectionChannel.put(redux_saga_1.END);
            requestChannel.put(redux_saga_1.END);
            __1.logger.verbose("server is being destroyed");
            server.stop();
        };
    });
    return [serverChannel, connectionChannel, requestChannel];
}
function* watchForNewConnections(channel) {
    while (true) {
        const conn = yield effects_1.take(channel);
        __1.logger.verbose(`handling new connection: ${conn.id}`);
        const state = yield effects_1.select();
        conn.sendState(state);
    }
}
function* watchForServerActions(channel) {
    while (true) {
        const action = yield effects_1.take(channel);
        __1.logger.verbose(`handling server action: ${action.type}`);
        yield effects_1.put(action);
    }
}
function* watchForServerRequests(requestChannel, targetConnection) {
    while (true) {
        const event = yield effects_1.take(requestChannel);
        const { request, respond } = event;
        if (__1.isRequestType("eval", request)) {
            if (targetConnection !== -1) {
                respond(targetConnection.eval(request.payload.value, request.payload.id));
            }
            else {
                respond({
                    error: true,
                    value: `unable to evaluate because the target is not connected`,
                });
            }
        }
        else if (__1.isRequestType("getScriptSource", request)) {
            if (targetConnection !== -1) {
                respond(targetConnection
                    .getScriptSource(request.payload.scriptId)
                    .then(value => ({ error: false, value })));
            }
            else {
                return {
                    error: true,
                    value: `unable to get source because the target is not connected`,
                };
            }
        }
        else if (__1.isRequestType("getProperties", request)) {
            if (targetConnection !== -1) {
                respond(targetConnection.getProperties(request.payload));
            }
            else {
                respond({
                    error: true,
                    value: `unable to get properties because the target is not connected`,
                });
            }
        }
        else if (__1.isRequestType("getPossibleBreakpointLocations", request)) {
            throw new Error();
        }
        else {
            throw new Error(`unhandled request type in server saga: ${request.type}`);
        }
    }
}
function* serverFlow(turbo, server, targetConnectionChannel) {
    const [serverChannel, connectionChannel, requestChannel] = setupServer(turbo, server);
    yield effects_1.fork(watchForNewConnections, connectionChannel);
    yield effects_1.fork(watchForServerActions, serverChannel);
    yield effects_1.takeLatest(targetConnectionChannel, watchForServerRequests, requestChannel);
}
exports.serverFlow = serverFlow;
//# sourceMappingURL=server.js.map