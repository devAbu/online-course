"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@turbo/core");
const child_process_1 = __importDefault(require("child_process"));
const NODE_EXIT_REGEX = /Waiting for the debugger to disconnect\.\.\.\n$/;
const NODE_PORT_REGEX = /Debugger listening on ws:\/\/([^:]+):(\d+)/;
class ManagedScript extends core_1.EmitterBase {
    constructor(config, turbo) {
        super();
        this.process = null;
        this.config = config;
        this.turbo = turbo;
    }
    start() {
        core_1.logger.debug("process: " + (this.process !== null));
        if (this.process === null) {
            this.spawn();
        }
    }
    stop() {
        if (this.process !== null) {
            this.process.kill();
            this.process = null;
        }
    }
    get isRunning() {
        return this.process !== null;
    }
    get pid() {
        return this.process ? this.process.pid : null;
    }
    spawn() {
        const nodePath = this.config.nodePath || this.turbo.env.nodePath;
        const args = ["--inspect-brk=0", this.config.script];
        core_1.logger.info(`starting node process ${nodePath} with args ${args.join(" ")}`);
        this.process = child_process_1.default.spawn(nodePath, args);
        this.process.on("exit", this.onExit.bind(this));
        this.process.on("kill", this.onExit.bind(this));
        if (this.process.stdout) {
            this.process.stdout.on("data", (data) => {
                this.fire("stdout", data.toString());
            });
        }
        if (this.process.stderr) {
            this.process.stderr.on("data", (data) => {
                const str = data.toString();
                if (NODE_EXIT_REGEX.test(str)) {
                    core_1.logger.debug("NODE_EXIT_REGEX matched");
                    this.stop();
                }
                else if (NODE_PORT_REGEX.test(str)) {
                    core_1.logger.debug("NODE_PORT_REGEX matched");
                    const matches = str.match(NODE_PORT_REGEX);
                    if (matches) {
                        const host = matches[1];
                        const port = parseInt(matches[2], 10);
                        core_1.logger.debug(`node matched ${host}:${port}`);
                        setTimeout(() => {
                            this.fire("started", {
                                interface: { host, port },
                            });
                        }, 100);
                    }
                }
                this.fire("stderr", str);
            });
        }
    }
    onExit() {
        core_1.logger.debug("node onExit");
        this.process = null;
        this.fire("stopped", undefined);
    }
}
function node(config, turbo) {
    if (!config.script) {
        throw new Error(`missing script option`);
    }
    return new ManagedScript(config, turbo);
}
exports.default = node;
//# sourceMappingURL=index.js.map