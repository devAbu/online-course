"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __importDefault(require("net"));
const fs_1 = __importDefault(require("fs"));
const core_1 = require("@turbo/core");
const jsonsocket_1 = require("./jsonsocket");
const serverconnection_1 = require("./serverconnection");
class SocketServer extends core_1.EmitterBase {
    constructor(turbo, sessionId) {
        super();
        this.lastClientId = 0;
        this.server = this.createServer();
        this.connections = new Set();
        this.turbo = turbo;
        this.socketPath = turbo.env.getTmpFile("sessions", sessionId);
        this.sessionId = sessionId;
        process.on("exit", () => {
            this.server.close();
            fs_1.default.unlinkSync(this.socketPath);
        });
        process.on("SIGHUP", () => {
            this.server.close();
            fs_1.default.unlinkSync(this.socketPath);
        });
    }
    get numConnections() {
        return this.connections.size;
    }
    start() {
        this.server.listen(this.socketPath);
    }
    stop() {
        this.server.close();
    }
    broadcastState(state) {
        for (const c of this.connections) {
            c.sendState(state);
        }
    }
    broadcastQuit() {
        for (const c of this.connections) {
            c.sendQuit();
        }
    }
    createServer() {
        const server = net_1.default.createServer();
        server.on("connection", (socket) => this.handleSocket(socket));
        server.on("error", (error) => {
            core_1.logger.error(`daemon error, ${error.toString()}`);
            this.startAfterDelay();
        });
        server.on("listening", () => {
            core_1.logger.verbose("daemon listening");
        });
        server.on("ready", () => {
            this.fire("ready", undefined);
        });
        server.on("close", () => {
            fs_1.default.unlinkSync(this.socketPath);
        });
        return server;
    }
    startAfterDelay() {
        setTimeout(() => {
            this.start();
        }, 2000);
    }
    handleSocket(rawSocket) {
        const socket = new jsonsocket_1.JsonSocket(rawSocket);
        this.lastClientId = (this.lastClientId + 1);
        const client = new serverconnection_1.SocketServerConnection(this.turbo, this.lastClientId, this.sessionId, socket);
        core_1.logger.info(`client:${client.id} connected`);
        client.on("close", () => {
            core_1.logger.verbose(`connection with client:${client.id} closed`);
            this.connections.delete(client);
            this.fire("disconnected", client);
        });
        client.on("action", (action) => {
            this.fire("action", action);
        });
        client.on("log", log => {
            this.fire("log", log);
        });
        client.on("quit", () => this.fire("quit", undefined));
        client.on("request", event => this.fire("request", event));
        this.connections.add(client);
        this.fire("connected", client);
    }
}
exports.SocketServer = SocketServer;
//# sourceMappingURL=server.js.map