import { SessionId, EmitterBase, Turbo, RequestId, Response, Request, ResponsePayload, RequestType, AnyMessage, ClientEvents } from "@turbo/core";
export interface ClientSocketEvents {
    close: void;
    data: any;
    error: Error;
    ready: void;
}
export interface ClientSocket {
    connect(path: string): void;
    end(): void;
    write(obj: any): void;
    on<T extends keyof ClientSocketEvents>(name: T, callback: (event: ClientSocketEvents[T]) => void): void;
}
interface UnmanagedClientOptions {
    type: "unmanaged";
    sessionId: SessionId;
    reconnect?: boolean;
    maxRetries?: number;
    socket: ClientSocket;
    connected: boolean;
}
interface ManagedClientOptions {
    type: "managed";
    sessionId: SessionId;
    reconnect?: boolean;
    maxRetries?: number;
}
export declare type ClientOptions = UnmanagedClientOptions | ManagedClientOptions;
export declare abstract class BaseClient<T extends ClientEvents = ClientEvents> extends EmitterBase<T> {
    private socketPath;
    private sessionId;
    private client;
    private connected;
    private reconnect;
    private maxRetries;
    private numRetries;
    private inflightRequests;
    constructor(turbo: Turbo, options: ClientOptions);
    get isConnected(): boolean;
    connect(): void;
    close(): void;
    ping(payload: string): Promise<ResponsePayload<"ping">>;
    private setup;
    connectAfterDelay(): void;
    private handleInboundMessage;
    private handleInboundRequest;
    private handleInboundResponse;
    protected abstract handleUnhandledMessage(msg: AnyMessage): void;
    protected abstract handleUnhandledRequest(req: Request<RequestType>): Promise<Response<RequestType>["payload"]>;
    protected sendRequest<T extends RequestType>(req: Request<T>): Promise<ResponsePayload<T>>;
    private sendResponse;
    protected sendMessage(obj: AnyMessage): void;
    protected generateRequestId(): RequestId;
}
export {};
