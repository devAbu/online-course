"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const baseclient_1 = require("./baseclient");
const mocksocket_1 = require("./mocksocket");
const core = __importStar(require("@turbo/core"));
const mocks_1 = require("./mocks");
jest.useFakeTimers();
jest.spyOn(core, "uuid").mockReturnValue("uuid-foo-bar");
class TestClient extends baseclient_1.BaseClient {
    handleUnhandledMessage(msg) {
        throw new Error(JSON.stringify(msg));
    }
    handleUnhandledRequest(_) {
        throw new Error("foo");
    }
}
describe("BaseClient", () => {
    test("correctly connects to the unix socket", () => {
        const socket = mocksocket_1.mockSocket();
        const client = new TestClient(mocks_1.TEST_TURBO, {
            type: "unmanaged",
            sessionId: "id",
            socket,
            connected: false,
        });
        client.connect();
        expect(socket.connect.mock.calls.length).toBe(1);
        expect(socket.connect.mock.calls).toEqual([["/tmp/turbo/sessions/id"]]);
    });
    test("correctly sends a ping", async () => {
        const socket = mocksocket_1.mockSocket();
        const client = new TestClient(mocks_1.TEST_TURBO, {
            type: "unmanaged",
            sessionId: "id",
            socket,
            connected: true,
        });
        const promise = client.ping("foobar");
        const response = {
            type: "res",
            payload: {
                id: "uuid-foo-bar",
                type: "ping",
                payload: "foobar",
            },
        };
        socket.fire("data", response);
        const pingReturn = await promise;
        expect(pingReturn).toBe("foobar");
        expect(socket.write.mock.calls.length).toBe(1);
        expect(socket.write.mock.calls).toEqual([
            [
                {
                    type: "req",
                    payload: {
                        type: "ping",
                        id: "uuid-foo-bar",
                        payload: "foobar",
                    },
                },
            ],
        ]);
    });
    test("handles the ready event", () => {
        const socket = mocksocket_1.mockSocket();
        const client = new TestClient(mocks_1.TEST_TURBO, {
            type: "unmanaged",
            sessionId: "id",
            socket,
            connected: true,
        });
        const listener = jest.fn();
        client.on("ready", listener);
        const callbacks = socket.on.mock.calls.filter(([name]) => name === "ready");
        expect(callbacks.length).toBe(1);
        const [_, callback] = callbacks[0];
        callback(undefined);
        expect(listener.mock.calls).toEqual([[undefined]]);
    });
    test("automatically reconnects on close", () => {
        const socket = mocksocket_1.mockSocket();
        const _ = new TestClient(mocks_1.TEST_TURBO, {
            type: "unmanaged",
            sessionId: "id",
            socket,
            connected: true,
        });
        const callbacks = socket.on.mock.calls.filter(([name]) => name === "close");
        expect(callbacks.length).toBe(1);
        const [__, callback] = callbacks[0];
        callback(undefined);
        jest.runAllTimers();
        expect(socket.connect.mock.calls.length).toBe(1);
    });
});
//# sourceMappingURL=baseclient.spec.js.map