"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __importDefault(require("net"));
const fs_1 = __importDefault(require("fs"));
const core_1 = require("@turbo/core");
const MAX_BUFFER_LENGTH = 4096;
class SocketLogServer extends core_1.EmitterBase {
    constructor(turbo) {
        super();
        this.connections = new Set();
        this.buffer = [];
        this.socketPath = turbo.env.getTmpFile("logs", core_1.uuid());
        this.server = net_1.default.createServer();
        this.server.on("connection", socket => {
            this.connections.add(socket);
            socket.on("end", () => {
                this.connections.delete(socket);
            });
            socket.on("close", () => {
                this.connections.delete(socket);
            });
            for (const line of this.buffer) {
                socket.write(line);
            }
        });
        this.server.on("error", error => {
            this.fire("error", error);
        });
        this.server.on("listening", () => {
            this.fire("ready", undefined);
        });
        this.server.on("close", () => {
            try {
                fs_1.default.unlinkSync(this.socketPath);
            }
            catch { }
        });
    }
    static create(turbo) {
        return new Promise((resolve, reject) => {
            const server = new SocketLogServer(turbo);
            server.once("ready", () => {
                resolve(server);
            });
            server.once("error", () => {
                reject(server);
            });
            server.start();
        });
    }
    start() {
        this.server.listen(this.socketPath);
    }
    log(msg) {
        for (const conn of this.connections) {
            try {
                conn.write(msg);
            }
            catch (e) {
                console.error(e.message);
            }
        }
        this.buffer.push(msg);
        if (this.buffer.length > MAX_BUFFER_LENGTH) {
            this.buffer.shift();
        }
    }
}
exports.SocketLogServer = SocketLogServer;
class LogClient extends core_1.EmitterBase {
    constructor(path) {
        super();
        this.path = path;
        this.socket = new net_1.default.Socket();
        this.socket.on("close", () => {
            this.connectAfterDelay();
        });
        this.socket.on("data", data => {
            this.fire("data", data.toString());
        });
    }
    connect() {
        this.socket.connect(this.path);
    }
    connectAfterDelay() {
        setTimeout(() => {
            this.connect();
        }, 3000);
    }
}
exports.LogClient = LogClient;
//# sourceMappingURL=log.js.map