"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const stream = __importStar(require("stream"));
const MAX_LENGTH = 2 ** 18;
class JsonSocket extends stream.Duplex {
    constructor(socket) {
        super({ objectMode: true });
        this.readingPaused = false;
        this.socket = socket;
        if (socket)
            this.wrapSocket(socket);
    }
    connect(path) {
        this.socket.connect(path);
    }
    wrapSocket(socket) {
        this.socket = socket;
        this.socket.on("close", hadError => this.emit("close", hadError));
        this.socket.on("connect", () => this.emit("connect"));
        this.socket.on("drain", () => this.emit("drain"));
        this.socket.on("end", () => this.emit("end"));
        this.socket.on("error", err => this.emit("error", err));
        this.socket.on("lookup", (err, address, family, host) => this.emit("lookup", err, address, family, host));
        this.socket.on("ready", () => this.emit("ready"));
        this.socket.on("timeout", () => this.emit("timeout"));
        this.socket.on("readable", this.onReadable.bind(this));
    }
    onReadable() {
        while (!this.readingPaused) {
            const lenBuf = this.socket.read(4);
            if (!lenBuf)
                return;
            const len = lenBuf.readUInt32BE();
            if (len > MAX_LENGTH) {
                this.socket.destroy(new Error("max length exceeded"));
                return;
            }
            const body = this.socket.read(len);
            if (!body) {
                this.socket.unshift(lenBuf);
                return;
            }
            let json;
            try {
                json = JSON.parse(body);
            }
            catch (ex) {
                this.socket.destroy(ex);
                return;
            }
            const pushOk = this.push(json);
            if (!pushOk)
                this.readingPaused = true;
        }
    }
    _read() {
        this.readingPaused = false;
        setImmediate(this.onReadable.bind(this));
    }
    _write(obj, _, cb) {
        const json = JSON.stringify(obj);
        const length = Buffer.byteLength(json);
        if (length > MAX_LENGTH) {
            this.socket.destroy(new Error("max length exceeded"));
            return;
        }
        const buffer = Buffer.alloc(4 + length);
        buffer.writeUInt32BE(length, 0);
        buffer.write(json, 4);
        this.socket.write(buffer, cb);
    }
}
exports.JsonSocket = JsonSocket;
//# sourceMappingURL=jsonsocket.js.map