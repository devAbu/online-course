"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@turbo/core");
const baseclient_1 = require("./baseclient");
class Client extends baseclient_1.BaseClient {
    constructor(turbo, options) {
        super(turbo, options);
        this.lastState = null;
        this.bufferLogs = true;
        this.logBuffer = [];
        core_1.logger.on("log", this.sendLog.bind(this));
        this.on("ready", () => {
            this.bufferLogs = false;
            this.flushLogs();
        });
        this.on("close", () => {
            this.bufferLogs = true;
        });
    }
    get state() {
        return this.lastState;
    }
    dispatch(action) {
        this.sendMessage({
            type: "action",
            payload: action,
        });
    }
    quit() {
        this.sendMessage({ type: "quit", payload: undefined });
    }
    eval(value, id) {
        return this.sendRequest({
            type: "eval",
            id: this.generateRequestId(),
            payload: {
                value,
                id,
            },
        });
    }
    getProperties(objectId) {
        return this.sendRequest({
            type: "getProperties",
            id: this.generateRequestId(),
            payload: objectId,
        });
    }
    getScriptSource(scriptId) {
        return this.sendRequest({
            type: "getScriptSource",
            id: this.generateRequestId(),
            payload: { scriptId },
        });
    }
    handleUnhandledMessage(msg) {
        if (core_1.isMessageType("sync", msg)) {
            this.lastState = msg.payload.state;
            this.fire("sync", msg.payload.state);
        }
        else {
            core_1.logger.error(`unhandled message with type ${msg.type}`);
        }
    }
    handleUnhandledRequest(req) {
        core_1.logger.error(`unhandled request with type ${req.type}`);
        return Promise.resolve(undefined);
    }
    flushLogs() {
        for (const log of this.logBuffer) {
            this.sendLog(log);
        }
        this.logBuffer = [];
    }
    sendLog(log) {
        if (this.bufferLogs) {
            this.logBuffer.push(log);
        }
        else {
            this.sendMessage({
                type: "log",
                payload: log,
            });
        }
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map