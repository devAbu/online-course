"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const net_1 = __importDefault(require("net"));
const core_1 = require("@turbo/core");
const jsonsocket_1 = require("./jsonsocket");
const RESPONSE_TIMEOUT = 5000;
class BaseClient extends core_1.EmitterBase {
    constructor(turbo, options) {
        super();
        this.maxRetries = 5;
        this.numRetries = 0;
        this.inflightRequests = new Map();
        this.sessionId = options.sessionId;
        this.socketPath = turbo.env.getTmpFile("sessions", options.sessionId);
        this.reconnect =
            typeof options.reconnect === "boolean" ? options.reconnect : true;
        if (options.type === "unmanaged") {
            this.client = options.socket;
            this.connected = options.connected;
        }
        else {
            this.client = new jsonsocket_1.JsonSocket(new net_1.default.Socket());
            this.connected = false;
        }
        if (options.maxRetries) {
            this.maxRetries = options.maxRetries;
        }
        this.setup();
    }
    get isConnected() {
        return this.connected;
    }
    connect() {
        if (this.numRetries > this.maxRetries) {
            throw new Error("exceeded max retries for connection");
        }
        if (!this.connected) {
            this.client.connect(this.socketPath);
            this.numRetries++;
        }
        else {
            throw new Error("attempted to connect already connected socket");
        }
    }
    close() {
        this.client.end();
    }
    async ping(payload) {
        return await this.sendRequest({
            type: "ping",
            id: this.generateRequestId(),
            payload,
        });
    }
    setup() {
        this.client.on("close", () => {
            this.connected = false;
            this.fire("close", undefined);
            if (this.reconnect) {
                this.connectAfterDelay();
            }
        });
        this.client.on("ready", () => {
            this.numRetries = 0;
            this.connected = true;
            this.fire("ready", undefined);
        });
        this.client.on("data", (msg) => {
            this.handleInboundMessage(msg);
        });
        this.client.on("error", (error) => {
            core_1.logger.error(`client error, ${error.toString()}`);
        });
    }
    connectAfterDelay() {
        setTimeout(() => {
            this.connect();
        }, 100);
    }
    handleInboundMessage(msg) {
        if (core_1.isRequest(msg)) {
            this.handleInboundRequest(msg.payload).then(payload => {
                this.sendResponse(msg.payload.id, msg.payload.type, payload);
            });
        }
        else if (core_1.isResponse(msg)) {
            this.handleInboundResponse(msg.payload);
        }
        else if (msg.type === "quit") {
            this.fire("quit", undefined);
        }
        else {
            this.handleUnhandledMessage(msg);
        }
    }
    handleInboundRequest(req) {
        if (core_1.isRequestType("ping", req)) {
            return Promise.resolve(req.payload);
        }
        else {
            return Promise.resolve(this.handleUnhandledRequest(req));
        }
    }
    handleInboundResponse(res) {
        const handle = this.inflightRequests.get(res.id);
        if (handle) {
            this.inflightRequests.delete(res.id);
            handle.cancelTimeout();
            handle.resolve(res.payload);
        }
        else {
            core_1.logger.error(`client received response for unknown request id: ${res.id}`);
        }
    }
    sendRequest(req) {
        return new Promise((resolve, reject) => {
            const id = setTimeout(() => {
                reject(new Error("response timeout reached"));
            }, RESPONSE_TIMEOUT);
            function cancelTimeout() {
                clearTimeout(id);
            }
            this.inflightRequests.set(req.id, {
                resolve: (value) => resolve(value),
                reject: (error) => reject(error),
                cancelTimeout,
            });
            this.sendMessage({
                type: "req",
                payload: req,
            });
        });
    }
    sendResponse(id, type, payload) {
        this.sendMessage({
            type: "res",
            payload: {
                id,
                type,
                payload,
            },
        });
    }
    sendMessage(obj) {
        if (this.connected) {
            this.client.write(obj);
        }
        else {
            throw new Error("attempted to write to client that isn't connected");
        }
    }
    generateRequestId() {
        return core_1.uuid();
    }
}
exports.BaseClient = BaseClient;
//# sourceMappingURL=baseclient.js.map